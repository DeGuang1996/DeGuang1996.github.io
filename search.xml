<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[卡特兰数]]></title>
    <url>%2F2019%2F06%2F08%2F%E5%8D%A1%E7%89%B9%E5%85%B0%E6%95%B0%2F</url>
    <content type="text"><![CDATA[通项公式Catalan序列是一个整数序列，其通项公式是 1h(n)=C(2n,n)/(n+1) (n=0,1,2,...) 其前几项为 : 1, 1, 2, 5, 14, 42, 132, 429, 1430, 4862, 16796, 58786, 208012, 742900, 2674440, 9694845, 35357670, 129644790, 477638700, 1767263190, 6564120420, 24466267020, 91482563640, 343059613650, 1289904147324, 4861946401452令h(0)=1,h(1)=1，catalan数满足递推式[1]： 123h(n)= h(0)*h(n-1)+h(1)*h(n-2) + ... + h(n-1)h(0) (n&gt;=2)例如：h(2)=h(0)*h(1)+h(1)*h(0)=1*1+1*1=2h(3)=h(0)*h(2)+h(1)*h(1)+h(2)*h(0)=1*2+1*1+2*1=5 另类递推式[2]： 1h(n)=h(n-1)*(4*n-2)/(n+1); 递推关系的解为： 1h(n)=C(2n,n)/(n+1) (n=0,1,2,...) 递推关系的另类解为： 1h(n)=c(2n,n)-c(2n,n+1)(n=0,1,2,...) 常见问题：出栈次序问题买票找零将多边行划分为三角形问题 一些笔试题1、16个人按顺序去买烧饼，其中8个人每人身上只有一张5块钱，另外8个人每人身上只有一张10块钱。烧饼5块一个，开始时烧饼店老板身上没有钱。16个顾客互相不通气，每人只买一个。问这16个人共有多少种排列方法能避免找不开钱的情况出现。1h(8)=16!/(8!*9!)=1430，所以总数=h(8)*8！*8！=16!/9 2、在图书馆一共6个人在排队，3个还《面试宝典》一书，3个在借《面试宝典》一书，图书馆此时没有了面试宝典了，求他们排队的总数？1h(3)=6!/(3!*4!)=5，所以总数=h(3)*3!*3!=180 参考资料：http://www.cnblogs.com/wuyuegb2312/archive/2013/07/16/3016878.html#code1https://www.cnblogs.com/youxin/p/3293345.html]]></content>
  </entry>
  <entry>
    <title><![CDATA[C++ 随机数引擎(C++ 11)]]></title>
    <url>%2F2019%2F06%2F08%2FC-%E9%9A%8F%E6%9C%BA%E6%95%B0%E5%BC%95%E6%93%8E-C-11%2F</url>
    <content type="text"><![CDATA[程序中需要用到随机数的地方很多，一般C++就是用srand种子+time函数生成随机数，但是这样会有两个主要问题：生成的区间有限，什么2^15-1(32767)，什么2^31-1(2147483647)，还有一些“奇怪”的数字单位时间内生成的随机数并不随机，time并不能解决随机问题，如果随机数生成的很快的话(可以for循环测试)为此，需要引入C++11中的random文件，其中封装了很多优秀的随机数生成器，包括均匀分布、正态分布、泊松分布等。 就拿围棋中用得最多的mt19937为例：1234std::random_device rd;std::shared_ptr&lt;std::mt19937&gt; mtEngine;this-&gt;mtEngine = std::make_shared&lt;std::mt19937&gt;(rd());(*mtEngine)(); 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263// ConsoleApplication4.cpp : 定义控制台应用程序的入口点。// #include "stdafx.h"#include &lt;random&gt;#include &lt;memory&gt;#include &lt;iostream&gt; using namespace std; class Random &#123;public: const static unsigned int maxRand = std::random_device::max(); static Random&amp; getInstance() &#123; static Random instance; return instance; &#125; unsigned int getInteger() noexcept &#123; return (*dist)(rd); &#125; unsigned int GetMTEngineInteger() noexcept &#123; return (*mtEngine)(); &#125; uint64_t GetMTEngine64Integer() noexcept &#123; return (*mtEngine64)(); &#125; unsigned int GetRand0Integer() noexcept &#123; return (*rand0Engine)(); &#125; auto GetRanlux48Integer() noexcept -&gt;decltype(auto) &#123; return (*ranlux48Engine)(); &#125; private: Random() noexcept &#123; mtEngine = std::make_shared&lt;std::mt19937&gt;(rd()); mtEngine64 = std::make_shared&lt;std::mt19937_64&gt;(rd()); dist = std::make_shared&lt;std::uniform_int_distribution&lt; unsigned int &gt;&gt;(std::uniform_int_distribution&lt; unsigned int &gt;(0, maxRand)); rand0Engine = make_shared&lt;std::minstd_rand0&gt;(rd()); ranlux48Engine = make_shared&lt;std::ranlux48&gt;(rd()); &#125; std::random_device rd; std::shared_ptr&lt;std::mt19937&gt; mtEngine; //32-bit Mersenne Twister by Matsumoto and Nishimura, 1998 std::shared_ptr&lt;std::mt19937_64&gt; mtEngine64; //64-bit Mersenne Twister by Matsumoto and Nishimura, 2000(马特赛特旋转演算法) std::shared_ptr&lt;std::minstd_rand0&gt; rand0Engine; std::shared_ptr&lt;std::ranlux48&gt; ranlux48Engine; std::shared_ptr&lt;std::uniform_int_distribution&lt; unsigned int &gt; &gt; dist;&#125;;int main()&#123; cout &lt;&lt; Random::getInstance().GetMTEngineInteger() &lt;&lt; endl; cout &lt;&lt; Random::getInstance().GetMTEngine64Integer() &lt;&lt; endl; cout &lt;&lt; Random::getInstance().GetRand0Integer() &lt;&lt; endl; cout &lt;&lt; Random::getInstance().GetRanlux48Integer() &lt;&lt; endl; cout &lt;&lt; Random::getInstance().getInteger() &lt;&lt; endl; return 0;&#125; 另外random中还有一堆分布函数，感觉是从matlab移植过来的，需要的话可以参考cppreference或者下面这篇文章：https://zh.cppreference.com/w/cpp/header/randomhttps://blog.csdn.net/u010487568/article/details/51526337]]></content>
  </entry>
</search>
